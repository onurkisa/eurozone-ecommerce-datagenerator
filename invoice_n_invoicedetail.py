"""
invoice_n_invoicedetail.py

This script processes order and order detail CSV files to generate invoices and invoice details.
It applies Eurozone VAT rates based on country codes, generates invoice dates considering business days,
and ensures one invoice per completed order. The output consists of two CSV files: invoices and invoice details.

Business Rules:
- Only orders with status 'Completed' are invoiced.
- One invoice per order.
- VAT rates are applied according to Eurozone country codes; default rate used otherwise.
- Invoice dates are generated by adding 1-7 business days to the order date.
- Invoice numbers are sequential and zero-padded.
- Batch processing is used for memory efficiency.
- Randomness is seeded for repeatability.

Inputs:
- CSV files matching 'orders_part_*.csv' and 'order_details_part_*.csv' in the specified base directory.

Outputs:
- 'invoices.csv' and 'invoice_details.csv' saved in the specified output directory.

Usage:
- Instantiate InvoiceGenerator with optional base_path, output_dir, and batch_size.
- Call generate_invoices() to process and generate invoice files.
"""
import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta
from decimal import Decimal, ROUND_HALF_UP
from tqdm import tqdm
import os
from pathlib import Path
import logging
from typing import Tuple, Optional, List, Dict
import warnings
import glob
warnings.filterwarnings('ignore')

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

EUROZONE_VAT_RATES = {
    'AT': 0.20, 'BE': 0.21, 'CY': 0.19, 'EE': 0.22, 'FI': 0.24,
    'FR': 0.20, 'DE': 0.19, 'GR': 0.24, 'IE': 0.23, 'IT': 0.22,
    'LV': 0.21, 'LT': 0.21, 'LU': 0.17, 'MT': 0.18, 'NL': 0.21,
    'PT': 0.23, 'SK': 0.20, 'SI': 0.22, 'ES': 0.21, 'HR': 0.25
}

DEFAULT_TAX_RATE = 0.21

random.seed(42)
np.random.seed(42)

class InvoiceGenerator:
    """Generates invoices and invoice details from order data.
    Attributes:
        base_path (Path): Directory containing order and order detail CSV files.
        output_dir (Path): Directory to save generated invoice CSV files.
        batch_size (int): Number of orders to process per batch.
        orders_df (Optional[pd.DataFrame]): DataFrame containing loaded orders.
        order_details_df (Optional[pd.DataFrame]): DataFrame containing loaded order details.
    """

    def __init__(self, base_path: str = '/content/drive/MyDrive/Colab Notebooks/new',
                 output_dir: str = 'output',
                 batch_size: int = 100000):
        """
        Initializes the InvoiceGenerator.
        Args:
            base_path (str): Path to directory containing input CSV files.
            output_dir (str): Path to directory where output CSV files will be saved.
            batch_size (int): Number of orders to process per batch.
        """
        self.base_path = Path(base_path)
        self.output_dir = Path(output_dir)
        self.batch_size = batch_size
        self.orders_df: Optional[pd.DataFrame] = None
        self.order_details_df: Optional[pd.DataFrame] = None

        self.output_dir.mkdir(parents=True, exist_ok=True)

    def load_data(self) -> Tuple[Optional[pd.DataFrame], Optional[pd.DataFrame]]:
        """
        Loads order and order detail CSV files dynamically using glob patterns.
        Returns:
            Tuple[Optional[pd.DataFrame], Optional[pd.DataFrame]]: DataFrames for orders and order details,
            or (None, None) if loading fails.
        """
        logger.info("Starting data loading process...")

        orders_files = sorted(glob.glob(str(self.base_path / 'orders_part_*.csv')))
        self.orders_df = self._load_csv_files(orders_files, "Orders")

        details_files = sorted(glob.glob(str(self.base_path / 'order_details_part_*.csv')))
        self.order_details_df = self._load_csv_files(details_files, "Order Details")

        if self.orders_df is None or self.order_details_df is None:
            logger.error("Failed to load required data files!")
            return None, None

        self._validate_data()

        return self.orders_df, self.order_details_df

    def _load_csv_files(self, file_paths: List[str], data_type: str) -> Optional[pd.DataFrame]:
        """
        Loads multiple CSV files with progress tracking.
        Args:
            file_paths (List[str]): List of file paths to load.
            data_type (str): Description of data type (for logging).
        Returns:
            Optional[pd.DataFrame]: Combined DataFrame or None if no files loaded.
        """
        existing_files = [f for f in file_paths if os.path.isfile(f)]

        if not existing_files:
            logger.warning(f"No {data_type} files found!")
            return None

        logger.info(f"Loading {len(existing_files)} {data_type} files...")
        dfs = []

        with tqdm(existing_files, desc=f"Loading {data_type}", unit="file") as pbar:
            for file_path in pbar:
                try:
                    df = pd.read_csv(file_path)
                    dfs.append(df)
                    pbar.set_postfix({"Records": len(df)})
                except Exception as e:
                    logger.warning(f"Failed to load {file_path}: {e}")

        if not dfs:
            return None

        combined_df = pd.concat(dfs, ignore_index=True)
        logger.info(f"{data_type} loaded: {len(combined_df):,} records")

        return combined_df

    def _validate_data(self) -> None:
        """
        Validates data consistency and required columns, logging errors and warnings.
        """
        if self.orders_df is None or self.order_details_df is None:
            logger.error("DataFrames not loaded; cannot validate.")
            return

        order_ids_orders = set(self.orders_df['order_id']) if 'order_id' in self.orders_df.columns else set()
        order_ids_details = set(self.order_details_df['order_id']) if 'order_id' in self.order_details_df.columns else set()
        matching_ids = order_ids_orders.intersection(order_ids_details)

        logger.info(f"Orders with details: {len(matching_ids):,} / {len(order_ids_orders):,}")

        if not matching_ids:
            logger.warning("No matching order IDs between orders and details!")

        required_order_cols = ['order_id', 'order_status', 'order_date', 'country_code']
        required_detail_cols = ['order_id', 'product_id', 'quantity', 'sales_amount']

        missing_order_cols = [col for col in required_order_cols if col not in self.orders_df.columns]
        missing_detail_cols = [col for col in required_detail_cols if col not in self.order_details_df.columns]

        if missing_order_cols:
            logger.error(f"Missing columns in orders: {missing_order_cols}")
        if missing_detail_cols:
            logger.error(f"Missing columns in order details: {missing_detail_cols}")

    @staticmethod
    def generate_invoice_date(order_date: str) -> datetime:
        """
        Generates an invoice date by adding 1-7 business days to the order date.
        Args:
            order_date (str): Order date string.
        Returns:
            datetime: Calculated invoice date.
        """
        order_datetime = pd.to_datetime(order_date)
        business_days_delay = random.randint(1, 7)
        invoice_date = order_datetime + pd.offsets.BDay(business_days_delay)
        return invoice_date

    @staticmethod
    def calculate_tax_amount(sales_amount: float, tax_rate: float) -> float:
        """
        Calculates tax amount with rounding half up to two decimals.
        Args:
            sales_amount (float): Sales amount value.
            tax_rate (float): Tax rate to apply.
        Returns:
            float: Calculated tax amount.
        """
        if pd.isna(sales_amount) or sales_amount <= 0:
            return 0.0

        sales_decimal = Decimal(str(sales_amount))
        tax_rate_decimal = Decimal(str(tax_rate))
        tax_amount = sales_decimal * tax_rate_decimal

        return float(tax_amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))

    @staticmethod
    def generate_invoice_number(index: int) -> str:
        """
        Generates a zero-padded invoice number string.
        Args:
            index (int): Invoice index number.
        Returns:
            str: Formatted invoice number.
        """
        return f"INV-{str(index + 1).zfill(8)}"

    def _process_order_batch(self, batch_orders: pd.DataFrame, batch_start_idx: int) -> Tuple[List[Dict], List[Dict]]:
        """
        Processes a batch of orders to generate invoices and invoice details.
        Args:
            batch_orders (pd.DataFrame): DataFrame of orders in the batch.
            batch_start_idx (int): Starting index for invoice numbering.
        Returns:
            Tuple[List[Dict], List[Dict]]: Lists of invoice and invoice detail dictionaries.
        """
        invoices, invoice_details = [], []

        batch_order_ids = set(batch_orders['order_id'])
        relevant_details = self.order_details_df[
            self.order_details_df['order_id'].isin(batch_order_ids)
        ].groupby('order_id')

        for idx, (_, order) in enumerate(batch_orders.iterrows()):
            try:
                invoice_date = self.generate_invoice_date(order['order_date'])
                invoice_time = f"{random.randint(9,17):02d}:{random.randint(0,59):02d}:{random.randint(0,59):02d}"

                order_id = order['order_id']
                if order_id not in relevant_details.groups:
                    continue

                items = relevant_details.get_group(order_id)

                country = order['country_code']
                tax_rate = EUROZONE_VAT_RATES.get(country, DEFAULT_TAX_RATE)

                items_copy = items.copy()
                items_copy['tax_amount'] = items_copy['sales_amount'].apply(
                    lambda x: self.calculate_tax_amount(x, tax_rate)
                )

                total_sales = items_copy['sales_amount'].sum()
                total_tax = items_copy['tax_amount'].sum()
                final_amount = total_sales + total_tax

                inv_id = self.generate_invoice_number(batch_start_idx + idx)
                invoices.append({
                    'invoice_id': inv_id,
                    'order_id': order_id,
                    'invoice_date': invoice_date.strftime('%Y-%m-%d'),
                    'invoice_time': invoice_time,
                    'unit_price': round(total_sales, 2),
                    'tax_amount': round(total_tax, 2),
                    'final_amount': round(final_amount, 2),
                    'invoice_status': 'Issued'
                })

                for detail_idx, (_, item) in enumerate(items_copy.iterrows(), 1):
                    invoice_details.append({
                        'invoice_detail_id': f"{inv_id}-{detail_idx:03d}",
                        'invoice_id': inv_id,
                        'product_id': item['product_id'],
                        'quantity': item['quantity'],
                        'sales_amount': round(item['sales_amount'], 2),
                        'tax_amount': round(item['tax_amount'], 2)
                    })

            except Exception as e:
                logger.warning(f"Error processing order {order.get('order_id', 'unknown')}: {e}")
                continue

        return invoices, invoice_details

    def _save_results(self, invoices_df: pd.DataFrame, invoice_details_df: pd.DataFrame) -> None:
        """
        Saves invoices and invoice details DataFrames to CSV files.
        Args:
            invoices_df (pd.DataFrame): DataFrame of invoices.
            invoice_details_df (pd.DataFrame): DataFrame of invoice details.
        """
        try:
            invoices_df.to_csv(self.output_dir / 'invoices.csv', index=False)
            invoice_details_df.to_csv(self.output_dir / 'invoice_details.csv', index=False)
            logger.info(f"Results saved to {self.output_dir / 'invoices.csv'} and {self.output_dir / 'invoice_details.csv'}")
        except Exception as e:
            logger.error(f"Failed to save results: {e}")

    def generate_invoices(self) -> Tuple[Optional[pd.DataFrame], Optional[pd.DataFrame]]:
        """
        Generates invoices and invoice details from loaded order data.
        Returns:
            Tuple[Optional[pd.DataFrame], Optional[pd.DataFrame]]: DataFrames of invoices and invoice details,
            or (None, None) if generation fails.
        """
        logger.info("Starting invoice generation process...")

        if self.orders_df is None or self.order_details_df is None:
            self.load_data()
            if self.orders_df is None or self.order_details_df is None:
                return None, None

        completed_orders = self.orders_df[self.orders_df['order_status'] == 'Completed'].copy()

        if completed_orders.empty:
            logger.warning("No completed orders found!")
            return None, None

        logger.info(f"Processing {len(completed_orders):,} completed orders...")

        all_invoices = []
        all_invoice_details = []
        total_batches = (len(completed_orders) + self.batch_size - 1) // self.batch_size

        with tqdm(total=len(completed_orders), desc="Generating Invoices", unit="order") as pbar:
            for batch_num in range(total_batches):
                start_idx = batch_num * self.batch_size
                end_idx = min(start_idx + self.batch_size, len(completed_orders))

                batch_orders = completed_orders.iloc[start_idx:end_idx]
                batch_invoices, batch_details = self._process_order_batch(batch_orders, len(all_invoices))

                all_invoices.extend(batch_invoices)
                all_invoice_details.extend(batch_details)

                pbar.update(len(batch_orders))
                pbar.set_postfix({
                    "Invoices": len(all_invoices),
                    "Details": len(all_invoice_details)
                })

        if not all_invoices:
            logger.warning("No invoices generated!")
            return None, None

        invoices_df = pd.DataFrame(all_invoices)
        invoice_details_df = pd.DataFrame(all_invoice_details)

        self._save_results(invoices_df, invoice_details_df)

        logger.info("Invoice generation completed successfully!")
        logger.info(f"Generated {len(invoices_df):,} invoices with {len(invoice_details_df):,} detail records")

        return invoices_df, invoice_details_df

    def get_summary_stats(self) -> Dict:
        """
        Generates summary statistics for loaded orders.
        Returns:
            Dict: Summary statistics including total orders, completed orders, completion rate, and countries covered.
        """
        if self.orders_df is None:
            return {}

        completed_orders = len(self.orders_df[self.orders_df['order_status'] == 'Completed'])
        total_orders = len(self.orders_df)

        return {
            "total_orders": total_orders,
            "completed_orders": completed_orders,
            "completion_rate": f"{(completed_orders/total_orders)*100:.1f}%" if total_orders > 0 else "0%",
            "countries_covered": len(self.orders_df['country_code'].unique()) if 'country_code' in self.orders_df.columns else 0
        }

def main():
    """Main entry point for invoice generation."""
    print("Starting Invoice Generation...")
    print("=" * 60)

    generator = InvoiceGenerator()
    try:
        invoices_df, invoice_details_df = generator.generate_invoices()

        if invoices_df is not None and invoice_details_df is not None:
            print("\n" + "=" * 60)
            print("GENERATION SUMMARY")
            print("=" * 60)

            stats = generator.get_summary_stats()
            for key, value in stats.items():
                print(f"{key.replace('_', ' ').title()}: {value}")

            print(f"\nInvoice Summary:")
            print(f"Total Invoices: {len(invoices_df):,}")
            print(f"Total Details: {len(invoice_details_df):,}")
            print(f"Total Amount: €{invoices_df['final_amount'].sum():,.2f}")
            print(f"Average Invoice: €{invoices_df['final_amount'].mean():.2f}")
            print("\nSample Invoice Data:")
            print(invoices_df.head())
            print("\nSample Invoice Details:")
            print(invoice_details_df.head())
        else:
            print("Invoice generation failed. Please check the logs for details.")

    except KeyboardInterrupt:
        print("\nProcess interrupted by user.")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise

if __name__ == "__main__":
    main()